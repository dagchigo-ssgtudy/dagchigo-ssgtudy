## 들어가기 전에

우리가 작성한 코드가 컴퓨터에서 실행되기 위해서는 0과 1로 이루어진 컴퓨터가 인식할 수 있는 기계어로 변역되어야 한다.

(C, 자바, C++, 자바스크립트 등과 같은 프로그래밍 언어를 사용하여 작성하는 프로그램을 고급 언어라고 합니다. 고급 언어는 사람 친화적 언어이다.)

기계어로 번역되는 방식(번역 시기)에는 인터프리터와 컴파일이 있다.

- 미리 번역을 해놓고 실행하면 컴파일
- 그때그때 번역하고 실행하면 인터프리터

# 컴파일

<img src='https://user-images.githubusercontent.com/80729831/171974501-6cb572fd-dfd6-4466-9201-253058cc1a40.png' />


- 소스코드의 전체를 보고 기계어로 변역한 다음 번역된 파일을 생성해 컴퓨터에서 실행시키는 방법이다.
- 한 언어에서 다른 언어로 번역하는 프로그램을 컴파일러
    - 컴파일러는 무조건 기계어로 번역할 필요 없다. (자바 → c언어)
- 파일들을 모두 번역해서 하나의 바이너리(또는 어셈블리)파일로 저장한다. 그러면 이후에 사용자가 이 바이너리 파일을 실행시키면 프로그램이 실행되는 것
- 장점
    - 실행 속도가 인터프리터에 비해 빠르다.
    - 한번 작성된 코드가 번역되어 실행 파일이 생성되면 이후로는 다시 번역할 필요 없이 번역된 실행파일을 실행시키면 되기 때문에 **시간상의 효율성**이 뛰어나다.
- 단점
    - 특정 시스템에서 번역된 실행 파일은 다른 시스템에서는 실행되지 않는다.
        - 윈도우에서 번역된 파일은 맥에서는 실행되지 않기 때문에 각각 시스템에 맞는 컴파일러를 별도로 만들어 줘야 한다
    - compile는 전체를 보고 작업을 한 후에 실행이 되기 때문에 실행되기 전까지 약간의 시간이 필요합니다.

# 인터프리터

<img src='https://user-images.githubusercontent.com/80729831/171974500-d53cf5a4-1c2c-485e-af4c-e50cee530d04.png' />

- 코드를 직접 한 줄씩 번역한 다음 바로 실행시키는 방법
- 인터프리터를 실행시키면 인터프리터가 해당 파일의 첫번째 줄을 읽어 기계어 명령어로 번역 한 후 CPU에 바로 돌린다.
- 스크립트 언어(Javascript, Python, PHP)들이 이 방법을 사용
- 장점
    - 인터프리터만 설치되어 있으면 같은 프로그램(스크립트)을 다른 컴퓨터에서도 실행 시킬 수 있다.
    - 한 줄씩 번역하여 실행시키기 때문에 매번 버그가 발생할 때마다 전체를 컴파일하지 않아도 돼서 디버깅에 편리하다
- 단점
    - 컴파일 방법보다 상대적으로 시간 효율성이 떨어진다.(느리다)

- 어떤 언어들은 바로 기계어로 번역되고, 어떤 언어들은 바이트코드로 한번 컴파일 된 후 해석(interpret)된다.

컴파일 vs 인터프리터 주요 차이점

- 컴파일러는 프로그램이 실행되기 전에 고급 프로그래밍 언어로 작성된 코드를 기계어로 한 번에 변환하는 반면, 인터프리터는 프로그램이 실행되는 동안 고급 프로그램 명령문을 하나씩 기계어로 변환한다.
- 해석된 코드는 느리게 실행되는 반면 컴파일된 코드는 더 빠르게 실행된다.
- Compiler는 컴파일 후 모든 오류를 표시하지만 Interpreter는 각 행의 오류를 하나씩 표시합니다.
- Compiler는 번역 연결 로딩 모델을 기반으로 하는 반면 Interpreter는 Interpretation Method를 기반으로 합니다.
- 컴파일러는 전체 프로그램을 사용하는 반면 인터프리터는 한 줄의 코드를 사용합니다.

최근에는 컴파일과 인터프리트 방법을 모두 사용하는 하이브리드 방식을 사용하고, 하드웨어 성능이 높아져서 예전처럼 컴파일 언어와 인터프리터 언어의 성능 차이를 사람이 체감할 정도로 크지 않다. 하이브리드 방식은 사람이 작성한 코드를 컴파일러를 사용해 중간 코드(바이트 코드)로 변환하고 이 중간 코드를 가상 머신을 통해 한 줄씩 기계어로 번역하여 즉시 실행시키는 방식이다.

# JIT 컴파일러
<img src='https://user-images.githubusercontent.com/80729831/171974502-70d5073e-b264-46db-bfd2-854ee9c2cfce.png' />
- 실행 시점에서 인터프리트 방식으로 기계어 코드를 생성하면서 그 코드를 캐싱하여, 같은 함수가 여러 번 불릴 때 매번 기계어 코드를 생성하는 것을 방지한다.
- 최근의 자바 가상 머신과 .NET, V8(node.js)에서는 JIT 컴파일을 지원한다. 즉, 컴파일러가 프로그램 코드를 바이트코드로 변환한 다음, 실제 바이트코드를 실행하는 시점에서 가상 머신이 바이트코드를 JIT 컴파일을 통해 기계어로 변환한다.
- 일반적으로 순수 컴파일만 하는 방식 보다는 느리다.
    - 이때 인터프리터를 사용하여 프로그램이 실행 중인 런타임 시 한 줄씩 읽기 때문에
    - 런타임 전 소스코드를 미리 읽어서 기계어로 변환하는 방식의 컴파일러보다는 느릴 수밖에 없다.

- 인터프리터와 컴파일러의 방식을 적절히 혼합해서 속도를 개선
    - 번역된 코드를 캐싱해둔 다음 똑같은 코드가 있다면 번역하지않고 캐싱해둔 값을 사용하여 매번 기계어 코드가 생성되는 것을 방지해 인터프리팅 시간을 단축시킨다.
    - 반복문에서 매번 같은 코드를 다시 번역해야 하는 문제

# 예시: V8 엔진

<img src='https://user-images.githubusercontent.com/80729831/171974631-53134999-c4ff-4588-9f7e-271ef9a69208.png' />

코드 한 줄을 해석하고 바로 실행하는 인터프리터 형식으로 자바스크립트를 바이트코드로 컴파일하여 기계어로 변환해주는 역할을 함

구글에서 C++ 로 작성됨

독립적으로 개발되어서 웹브라우저 뿐 아니라 C++ 프로그램에 별도로 내장하여 실행 가능

크롬, 엣지 브라우저에서 사용중

## 현재 엔진 구조

- Ignition, TurboFan 의 기능이 좋아지면서 과거에 사용되던 Full-codegen, Crankshaft를 제거

## 작동원리

<img src='https://user-images.githubusercontent.com/80729831/171974629-bf03bf3a-559c-4de8-a5d2-82581339367f.png'/>

### Parser

- 소스코드 분석 후 AST로 변환

### AST (Abstract Syctax Tree, 추상 구문 트리)

```jsx
{
  type: 'FunctionDeclaration',
  name: 'hello'
  arguments: [
    {
      type: 'Variable',
      name: 'name'
    }
  ]
  // ...
}
```

### Ignition

- 원본 소스 코드를 바이트 코드로 변환하는 인터프리터
    - 모든 소스를 한 번에 해석하는 컴파일 방식이 아닌 코드 한 줄 한 줄 실행될 때마다 해석하는 방식
- 수시로 코드를 파싱하는 작업을 최소화하고 코드의 양도 줄임으로 메모리 공간을 효율적으로 관리할 수 있게함
- node --print-bytecode 파일 → 바이트 코드로 확인 할 수 있음

### TurboFan

- 5.9 버전 전에 사용되었던 Crankshaft 컴파일러를 완전히 대체한 컴파일러
- 바이트 코드로 수시로 변환하는 과정을 최소화하기 위해 사용됨
- 최적화 기법
    - Hidden Class
        - 자바스크립트의 단점
            - 자바스크립트는 정적 타입 (number, string 등) 외 모든 데이터를 객체로 취급
            - 객체 형태가 정해져 있지 않아 동적으로 변할 수 있기 때문에 메모리 할당에 있어 동적인 변화에 대한 정보를 따로 저장해야해서 다른 언어에 비해 성능이 떨어짐
        - 위와 같은 단점을 극복하기 위한 최적화 방법
            - 새로운 객체를 생성할 때 새로운 히든 클래스(C01)를 생성
                
                <img src='https://user-images.githubusercontent.com/80729831/171974702-e3bbdb45-6e9e-4d56-999d-89df7ea898ab.png'/>
                
            - 객체 수정 시 이전 히든 클래스 (C01)을 상속받은 새로운 히든 클래스 (C02)를 생성하고 이름 프로퍼티를 오프셋 0에 할당
                      <img src='https://user-images.githubusercontent.com/80729831/171974701-89fedfd4-57fd-45db-827b-e3c5783857bf.png'/>
                            <img src='https://user-images.githubusercontent.com/80729831/171974699-bf742699-02d2-4d3f-808a-9593e1f825ef.png'/>
                
            - 비슷한 객체로 생성, 수정 하면 새로운 히든클래스를 만드는 것이 아니라 기존이 있던 히든 클래스를 재사용함
            - const user ={} → Hidden class (C01)
            - 코드의 성능 향상을 최대화하려면 동적 프로퍼티 추가를 최소화 시키는 것이 좋음

- **Inline Caching**
    - 객체 필드에 접근을 할 때 hidden class를 사용한다면 결국 우리가 얻고 싶은 것은 접근하려는 필드의 오프셋 값이고 이 값을 캐싱
    - 동일한 히든 클래스의 동일한 메소드에 대해 두 번의 성공적인 호출 후에는 캐싱하여 해당 객체 포인터에 프로퍼티 오프셋을 더해 놓는다
    - 이후 해당 메소드에 대한 호출에 대해 이전에 찾아두었던 오프셋을 이용해 직접 메모리 주소로 찾음